{"title":"Shorthest path vizualization","markdown":{"yaml":{"title":"Shorthest path vizualization","execute":{"echo":false},"format":{"html":{"code-fold":true,"code-summary":"Show the code"}}},"headingText":"Choose the first Actor:","containsRefs":false,"markdown":"\n\nOn this page you can explore the links between you favorite actors ! Just choose in the inputs below and the shortest path between the both will be displayed, if it exists. \n\nThe canvas here is limited so some node might not be displayed correctly, in that case you can just move the nodes around. Also you can hover over the nodes and links, if the text is difficult to read. \\\n**Quick disclaimer**: this page might take some time to load because we need to load the entire graph to do real time computation.\n\n\n```{ojs}\n// base https://stackoverflow.com/questions/32527026/shortest-path-in-javascript\n// wanted to do better than a simple bfs but performance seems okay\n// so leaving this modified code sample\nfunction Graph() {\n  var neighbors = this.neighbors = {};\n  this.addEdge = function (u, v, val) {\n    if (neighbors[u] === undefined) {\n      neighbors[u] = [];\n    }\n    neighbors[u].push(({id: v, value: val}));\n    if (neighbors[v] === undefined) {\n      neighbors[v] = [];\n    }           \n    neighbors[v].push(({id: u, value: val}));\n  };\n\n  return this;\n}\n\nfunction shortestPath(graph, source, target) {\n  if (source == target) {\n    return source;\n  }\n  var queue = [ source ],\n      visited = { [source]: true },\n      predecessor = {},\n      tail = 0;\n  while (tail < queue.length) {\n    var u = queue[tail++],\n        neighbors = graph.neighbors[u];\n    for (var i = 0; i < neighbors.length; ++i) {\n      var v = neighbors[i];\n      if (visited[v.id]) {\n        continue;\n      }\n      visited[v.id] = true;\n      if (v.id === target) {\n        var path = [ v ];\n        if (u !== source) {\n          path.push(({id: u, value: v.value}));\n          u = predecessor[u]; \n        }\n        console.log(u)\n        while (u.id !== source) {\n          path.push(u);\n          u = predecessor[u.id];          \n        }\n        path.push(u);\n        path.reverse();\n        return path;\n      }\n      predecessor[v.id] = ({id: u, value: v.value});\n      queue.push(v.id);\n    }\n  }\n  return [];\n}\n```\n\n\n```{ojs}\nd3 = require(\"d3\")\nunderscore = require(\"underscore\")\nnodes = FileAttachment(\"/data/js_graph/nodes.json\").json()\nnames = nodes.map(x => x.name)\nedges1 = FileAttachment(\"/data/js_graph/edges1.json\").json()\nedges2 = FileAttachment(\"/data/js_graph/edges2.json\").json()\nedges = edges1.concat(edges2)\n```\n\n```{ojs}\nfunction get_graph(edges) {\n  var g = new Graph();\n  edges.forEach(x => g.addEdge(x.source, x.target, x.value));\n  return g;\n}\ngraph = get_graph(edges)\n```\n\n```{ojs}\nfunction transform_dict_id(nodes) {\n  var dict = {};\n  nodes.forEach(x => dict[x.id] = x);\n  return dict;\n}\nid_to_node = transform_dict_id(nodes)\nfunction transform_dict_name(nodes) {\n  var dict = {};\n  nodes.forEach(x => dict[x.name] = x);\n  return dict;\n}\nname_to_node = transform_dict_name(nodes)\n```\n\n```{ojs}\nviewof search1 = Inputs.search(names)\nviewof actor1 = Inputs.select(underscore.sample(search1, 100))\n```\n\n### Choose the second Actor:\n```{ojs}\nviewof search2 = Inputs.search(names)\nviewof actor2 = Inputs.select(underscore.sample(search2, 100))\n```\n\n```{ojs}\nactor1_node = name_to_node[actor1]\nactor2_node = name_to_node[actor2]\n```\n\n```{ojs}\n//| output: false\npath = {\n  if (graph.neighbors !== undefined && actor1 !== null && actor2 !== null && actor1 !== actor2) {\n    return shortestPath(graph, actor1_node.id, actor2_node.id);\n  } else {\n    return [];\n  }\n}\npathNodes = path.map(x => id_to_node[x.id])\npathNodes.forEach(x => x[\"group\"] = \"Shortest path\")\npathEdges = path.reduce((xs, x) => {\n  var last = xs.pop()\n  if (last != undefined) {\n    xs.push({source: last.id, target: x.id, value: last.value, group: \"Shortest path\"})\n  }\n  xs.push(x)\n  return xs\n}, [])\nuseless = pathEdges.pop()\n```\n\n```{ojs}\nfunction get_neigh_node(pathNodes) {\n  var pathNId = pathNodes.map(x => x.id);\n  var pathNeighDict = pathNodes.flatMap(x => graph.neighbors[x.id]).filter(x => !pathNId.includes(x.id));\n  var pathNeigh = {};\n  pathNeighDict.map(x => {\n    if (pathNeigh[x.id] === undefined) {\n      var n = id_to_node[x.id];\n      n[\"count\"] = 1;\n      pathNeigh[x.id] = n;\n    } else {\n      pathNeigh[x.id][\"count\"] += 1;\n    }\n  })\n  var r = [];\n  Object.entries(pathNeigh).forEach(function([key, value]) {\n    var group = \"\"\n    if (value.count >= 4) {\n      group = \"4+-connected\";\n    } else {\n      group = value.count + \"-connected\";\n    }\n    r.push({id: value.id, name: value.name, group: group})\n  }); \n  return r;\n}\npathNeighNodes = get_neigh_node(pathNodes).filter(x => x.group !== \"1-connected\" && x.group !== \"2-connected\")\nfunction get_neigh_edges(pathNodes, pathNeighNodes) {\n  var pathNeighNodesId = pathNeighNodes.map(x => x.id);\n  var pathNeighDict = pathNodes.flatMap(x => graph.neighbors[x.id].filter(z => pathNeighNodesId.includes(z.id)).map(y => ({source: x.id, target: y.id, value: y.value, group: \"Neighbors\"})));\n  return pathNeighDict;\n}\npathNeighEdges = get_neigh_edges(pathNodes, pathNeighNodes)\ndata = ({\n    nodes: pathNodes.concat(pathNeighNodes),\n    links: pathEdges.concat(pathNeighEdges),\n})\n```\n\n```{ojs}\nfunction output_path_exist() {\n  if (graph.neighbors !== undefined && path !== undefined && path.length === 0) {\n    return \"There is no path between \" + actor1 + \" and \" + actor2 + \".\";\n  } else {\n    return \"\";\n  }\n}\nDOM.text(output_path_exist())\ncolors = d3.scaleOrdinal()\n  .domain([\"Shortest path\", \"3-connected\", \"4+-connected\"])\n  .range(['#4797C9','#fff686','#9e79db']);\n```\n\n```{ojs}\nchart = {\n  var height = 600;\n  var width = 900;\n  var svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  var legend = svg.selectAll(\"legend\")\n    .data(colors.domain())\n    .enter()\n    .append(\"g\") \n    .attr(\"transform\", (d, i) => `translate(${width / 2 - 120},${i * 20 - height / 2 + 20})`); \n\n  legend.append(\"circle\")\n    .attr(\"cx\", 0)\n    .attr(\"cy\", 0)\n    .attr(\"r\", 5)\n    .attr(\"fill\", colors);\n\n  legend.append(\"text\")\n    .attr(\"x\", 10)\n    .attr(\"y\", 5)\n    .text(d => d);\n\n  var simulation = d3.forceSimulation()\n    .force(\"center\", d3.forceCenter())\n    .force(\"charge\", d3.forceManyBody().strength(d => {\n      if (d.group === \"Shortest path\") {\n        return -3000;\n      } else {\n        return -50;\n      }\n    }).distanceMax(450).distanceMin(85))\n    .force(\"link\", d3.forceLink().id(d => d.id));\n\n  var links = svg.selectAll(\"links\")\n    .data(data.links)\n    .enter()\n    .append(\"line\")\n    .attr(\"stroke\", \"#BDBDBD\")\n    .attr(\"stroke-width\", l => {\n      if (l.group === \"Shortest path\") {\n        return l.value.length * 5;\n      } else {\n        return 1;\n      }\n    });\n\n  links.append(\"title\").text(l => l.value);\n\n  var linkText = svg.selectAll(\"links\")\n    .data(data.links)\n    .enter()\n    .append(\"text\")\n\t  .attr(\"fill\", \"#0022B7\")\n    .text(l => {\n      if (l.group === \"Shortest path\") {\n        return l.value;\n      } else {\n        return \"\";\n      }\n    });\n\n  var nodes = svg.selectAll(\"nodes\")\n    .data(data.nodes)\n    .enter()\n    .append(\"g\")\n    .call(d3.drag()\n      .on(\"start\", dragstarted)\n      .on(\"drag\", dragged)\n      .on(\"end\", dragended));\n\n  nodes.append(\"title\").text(d => d.name);\n\n  var circles = nodes.append(\"circle\")\n    .attr(\"class\", \"circle\")\n    .attr(\"r\", d => {\n      if (d.group === \"Shortest path\") {\n        return 30;\n      } else {\n        return 5;\n      }\n    })\n    .attr(\"fill\", d => colors(d.group))\n    .attr(\"stroke\", \"#ffffff\")\n    .attr(\"stroke-width\", 2)\n\n  var text = nodes.append(\"text\")\n    .style(\"fill\", \"black\")\n    .style(\"font-weight\", \"bold\")\n    .attr(\"dx\", 0)\n    .attr(\"dy\", 5)\n    .attr(\"text-anchor\",\"middle\")\n    .text(d => {\n      if (d.group === \"Shortest path\") {\n        return d.name;\n      } else {\n        return \"\";\n      }\n    });\n\n  simulation.nodes(data.nodes);\n  simulation.force(\"link\").links(data.links)\n  simulation.on(\"tick\", function () {\n    links.attr(\"x1\", d => d.source.x)\n      .attr(\"y1\", d => d.source.y)\n      .attr(\"x2\", d => d.target.x)\n      .attr(\"y2\", d => d.target.y);\n\n    nodes.attr(\"transform\", d => \"translate(\" + d.x + \",\" + d.y + \")\")\n\n    linkText.attr(\"x\", function(d) {\n\t        if (d.target.x > d.source.x) { return (d.source.x + (d.target.x - d.source.x)/2); }\n\t        else { return (d.target.x + (d.source.x - d.target.x)/2); }\n\t    })\n\t    .attr(\"y\", function(d) {\n\t        if (d.target.y > d.source.y) { return (d.source.y + (d.target.y - d.source.y)/2); }\n\t        else { return (d.target.y + (d.source.y - d.target.y)/2); }\n\t    });\n  });\n\n  function dragstarted(event) {\n    if (!event.active) simulation.alphaTarget(0.3).restart();\n    event.subject.fx = event.subject.x;\n    event.subject.fy = event.subject.y;\n  };\n  \n  function dragged(event) {\n    event.subject.fx = event.x;\n    event.subject.fy = event.y;\n  };\n  \n  function dragended(event) {\n    if (!event.active) simulation.alphaTarget(0);\n    event.subject.fx = null;\n    event.subject.fy = null;\n  };\n\n  \n  \n  return Object.assign(svg.node(), {scales: d3.schemeTableau10});\n}\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"viz.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","theme":"cosmo","title":"Shorthest path vizualization"},"extensions":{"book":{"multiFile":true}}}}}